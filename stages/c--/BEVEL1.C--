extern long NomDets;   // порЯдковый номер вырезаемой детали
char OK,OK1,ch;                                  /* переменнаЯ длЯ поддержки диалога            */
static long loop,W30;                             /* переменные поддержки цикла                  */
extern long shag;                                 // индекс массива удалениЯ
char OLD[64],OLP[64];                            /* переменные длЯ ввода имен файлов и партидов */
extern float W72,W144,W145,W97,Lange,DCutt;      /* внешние переменные                          */
extern float W7,W8,W86,W87,W6,W1,W2;             /* внешние переменные                          */
extern float XW1,YW1,W4,W5,W91,W110,W120;        /* внешние переменные                          */
extern float XFrom,YFrom;
extern float NextPx,NextPy;
extern long   Sposob;
extern long pin;
extern float pinok;
extern float A0,A1,A2,A3,A4,A5;
float        W70,W111,Kom,W22,Lan,W4n,W2n,W2k,W12;
long          Fint,Adres,nom,menu_1;
extern float x1,y1,x2,y2,tp,x3,y3,xt,yt;
float  PosSpan,KolSpan;
 
shag=0;
pinok=0;
A0=1;  // номер подпрограммы
A1=15; // дистанциЯ врезки
A2=1; // спан длЯ внешних контуров
A3=0; // позициЯ на спане
A4=1; // спан длЯ внутренних контуров
A5=0; // позициЯ на спане
pin=0;
LOAD(); // Команды Сириуса, пишутсЯ заглавными буквами
SEQ(1);
if (KURSEQ==-1)
{
 NEW(1);
 CUR();
 CEN();
 DRA(0);     /* сириуснаЯ команда центровки                   */
 N(9999);   /* сириуснаЯ команда прогонки последовательности */
}
else
{
 CUR();
 CEN();
 DRA(0);     /* сириуснаЯ команда центровки                   */
}
pin=0;
K();
print("                        ");
Kom=HEAP[7];
if(Kom!=0)
   OK:='N';
else
 {
   N(1);
   K();
   print("                        ");
   Kom=HEAP[7];
   if(Kom!=0)
   {
     OK:='N';
     N(-1);
   }
   else
     OK:='Y';
 }
nastr1();
W111=1;
if (OK!='N') /* проверка введенного символа на неравенство с буквой N */
{
/* сириучнаЯ команда чистки экрана, центровки и рисованиЯ     */
 ST1();
 ST(); /*  старт подпрограммы ST из файла ST.C--              */
 CUTTER(0.0);
 R();
 DRA(0);
 N(999);
}
else
{
  OK:='Y';
  print("Хотите прогнать ДО КОНЦА([Y]/N)>");                /* печатать на нижней ком строке               */
 W(-1);
 print("                                  ");
 if (S_GETCH>31) OK=S_GETCH;
  /* если ничего не ввели остаетсЯ старое значение переменных */
  CUR();
  CEN();
  DRA(0);     /* сириуснаЯ команда центровки                   */
  if (OK!='N') /* проверка введенного символа на неравенство с буквой N */
  {
    N(9999);   /* сириуснаЯ команда прогонки последовательности */
  }
}
menu_1=8;
loop=1;
 print("-Выберите нижний угол длЯ обхода  ");
 W(-2);
 print("                                                                   ");
 x1=HEAP[13];     // перваЯ точка спана
 y1=HEAP[12];     // перваЯ точка спана
 x2=HEAP[11];    // втораЯ точка спана
 y2=HEAP[10];    // втораЯ точка спана
 tp=HEAP[9];      // фактор кривизны
 x3=HEAP[22];     // ближайщаЯ точка к спану
 y3=HEAP[21];     // ближайщаЯ точка к спану
 
 W7=HEAP[3];
 W2=HEAP[4];
 W22=W2;
 OK=S_GETCH;
 PosSpan=HEAP[8];  // позициЯ спана напротив крестообразного курсора
 W12=HEAP[8];         // позициЯ на спане напротив крестообразного курсора
 NewFun(302,0,W7);
 NewFun(302,0,HEAP[67]); //  найти количство точек по оригинальному контуру
 KolSpan=HEAP[75];   //  количество точек на контуре
 if (PosSpan>0.5)
    {
      W12=1.0;
      W4=W2;
      W2=W2+1;
      if (W2>=KolSpan) W2=1;
    }
   else
    {
      W12=0.0;
      W4=W2-1;
      if (W4<1) W4=KolSpan-1;
    }
  if (W22==W2) FROM(x1,y1,0);
  else FROM(x2,y2,0);
  W70=HEAP[9];
  LEAD(0);
  M(5);
  PROF(W7,0.0,W2,0,0,W4,1,0);
  M(6);
  M(30);
  UPCUT();
  MOVE (W7,0.0,W4,1,0);
  TON(2);
  Lan=50;
  print("ДистанциЯ реза("+str(Lan,10,2)+")>"); // ввод дистанции реза 
  read(Lan);
  PROF(W7,0.0,W4,1,0,W4,1,-Lan);
  TOF(123);
  M(38);
  W4n=W4;
  W2n=W2;
// **************************
 print("-Выберите верхний угол длЯ реза  ");
 W(-2);
 print("                                                                   ");
 x1=HEAP[13];     // перваЯ точка спана
 y1=HEAP[12];     // перваЯ точка спана
 x2=HEAP[11];    // втораЯ точка спана
 y2=HEAP[10];    // втораЯ точка спана
 tp=HEAP[9];      // фактор кривизны
 x3=HEAP[22];     // ближайщаЯ точка к спану
 y3=HEAP[21];     // ближайщаЯ точка к спану
 
 W7=HEAP[3];
 W2=HEAP[4];
 W22=W2;
 OK=S_GETCH;
 PosSpan=HEAP[8];  // позициЯ спана напротив крестообразного курсора
 W12=HEAP[8];         // позициЯ на спане напротив крестообразного курсора
 NewFun(302,0,W7);
 NewFun(302,0,HEAP[67]); //  найти количство точек по оригинальному контуру
 KolSpan=HEAP[75];   //  количество точек на контуре
 if (PosSpan>0.5)
    {
      W12=1.0;
      W4=W2;
      W2=W2+1;
      if (W2>=KolSpan) W2=1;
    }
   else
    {
      W12=0.0;
      W4=W2-1;
      if (W4<1) W4=KolSpan-1;
    }
 M(5);
 MOVE (W7,0.0,W2,0,0);
 M(6);
 M(29);
 CLIMB();
 TON(2);
 PROF(W7,0.0,W2,0,0,W2,0,Lan);
 TOF(123);
 M(38);
 GOHOME();
 MOVE (W7,0.0,W4n,1,0); 
 STOP();
 M(30);
 UPCUT();
 TON(123);
 MOVE (W7,0.0,W4n,1,-5); 
 MOVE (W7,0.0,W4n,1,-10);
 M(51);
 MOVE (W7,0.0,W4n,1,-15);
 MOVE (W7,0.0,W4n,1,-20);
 MOVE (W7,0.0,W4n,1,-25);
 MOVE (W7,0.0,W4n,1,-30);
 W4n=W4n-1;
 if (W4n<1) W4n=KolSpan-1; 
 print("-Выберите нижний правый угол лепестка ");
 W(-2);
 print("                                                                   ");
 x1=HEAP[13];     // перваЯ точка спана
 y1=HEAP[12];     // перваЯ точка спана
 x2=HEAP[11];    // втораЯ точка спана
 y2=HEAP[10];    // втораЯ точка спана
 tp=HEAP[9];      // фактор кривизны
 x3=HEAP[22];     // ближайщаЯ точка к спану
 y3=HEAP[21];     // ближайщаЯ точка к спану
 
 W7=HEAP[3];
 W2=HEAP[4];
 W22=W2;
 OK=S_GETCH;
 PosSpan=HEAP[8];  // позициЯ спана напротив крестообразного курсора
 W12=HEAP[8];         // позициЯ на спане напротив крестообразного курсора
 NewFun(302,0,W7);
 NewFun(302,0,HEAP[67]); //  найти количство точек по оригинальному контуру
 KolSpan=HEAP[75];   //  количество точек на контуре
 if (PosSpan>0.5)
    {
      W12=1.0;
      W4=W2;
      W2=W2+1;
      if (W2>=KolSpan) W2=1;
    }
   else
    {
      W12=0.0;
      W4=W2-1;
      if (W4<1) W4=KolSpan-1;
    }
 W2k=W2+1;
 if (W2>=KolSpan) W2k=1;
 PROF(W7,0.0,W4n,1,0,W2k,0,0);
 M(48);
 MOVE (W7,0.0,W2,0,0);
 MOVE (W7,0.0,W2,0,-20);
 TOF(123);
 M(52);
 M(38);
 STOP();
       
