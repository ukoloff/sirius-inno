float KTn[300],KTv[300],Xc[300],Yc[300],H1[300],B1[300],H2[300],B2[300],NM,NM1,Mx,Dx,Ly,Hk1[4][300],Hk2[4][300],Bk1[4][300],Bk2[4][300],Xck[4][300],Yck[4][300],MinX,MinY;
Long NambN,NambV,del,stop,end,H;
char putin[100],stroka[150];
Long filt,i,j,k1,k2,k3,n,k,m,kolKt;
float Px0,Py0,KVr[3][300],Pnx,Pny,Pn1x,Pn1y,CosF,F,F1,n1,Xk[300],yk[300],D,D1;
Extern float BLOK[300][300],KNT[100],SPv,MasKt[4][300];
Extern Long KolBl,NMB;
extern float Lange;    // дистанциЯ врезки
extern float spanvx;   //    выход из способа резки УГОЛ

putin=PATHNAM+"REZVREM.RRR";
NEWFUN(323,0,0);                 //Сортировка контуров//
NEWFUN(322,0,0);



Filt:=fopen(putin,"rt");         //Выбор внешних контуров//
NambN=1;
fscan(Filt,stroka);
//Napr:=Val(substr(stroka,61,6));        //Направление реза//
NM=Val(substr(stroka,53,6));
KTn[NambN]=Val(substr(stroka,1,7));
while(! feof(Filt))
{  
 fscan(Filt,stroka);
 NM1=Val(substr(stroka,53,6));
 if(NM!=NM1) 
  {
   NambN++;
   KTn[NambN]=Val(substr(stroka,1,7));
   NM=NM1;

  }
  else KTn[NambN]=Val(substr(stroka,1,7));

}
fseek(Filt,0);                                    //Внутренние контура//
i=1;
NambV=0;
while(! feof(Filt))
{
 fscan(Filt,stroka);

 if(KTn[i]==Val(substr(stroka,1,7))) i++;
  else
   {
    NambV++;
    KTv[NambV]=Val(substr(stroka,1,7));
   }
}
if(KTv[NambV]==KTn[NambN-1]) NambV--;
NambN--;

i=1;
While(i<=NambN)                    //координаты центра опис пр,шир и выс//
{
 NEWFUN(320,0,KTn[i]);
 Xc[i]=HEAP[56]+(HEAP[57]-HEAP[56])/2;
 Yc[i]=HEAP[58]+(HEAP[59]-HEAP[58])/2;
 //B[i]= HEAP[57]-HEAP[56];                
 //H[i]= HEAP[59]-HEAP[58];
 B1[i]=HEAP[56];
 B2[i]=HEAP[57];
 H1[i]=HEAP[58];
 H2[i]=HEAP[59];



 i++;
}


del=1;

i=1;
k1=0;
While(i<=NambN)
{
  if(KTn[i]!=1)
   {
    k1++;
    MasKt[k1][1]=KTn[i];
    Hk1[k1][1]=H1[i];
    Hk2[k1][1]=H2[i];
    Bk1[k1][1]=B1[i];
    Bk2[k1][1]=B2[i];
    Xck[k1][1]=Xc[i];
    Yck[k1][1]=Yc[i];
   } 
 i++;
}




/////////////

if(del==5)                         //опред соседей//
{
 H1[1]=Hk1[1]-30;
 H2[1]=Hk2[1]+30;
 B1[1]=Bk1[1]-30;
 B2[1]=Bk2[1]+30;
 i=2;
 While(i<=k1)
 {
  if( ((Hk1[i]<=H2[1])&&(Hk2[i]>=H1[1])) && ((Bk2[i]>=B1[1])&&(Bk1[i]<=B2[1])) ) print(MasKt[i][1]);
  i++;
 }


}








Px0=0;
PY0=1;
KolBl=0;
stop=0;
end=0;
KolKt=1;

if(del==1)
{
 While(stop==0)
 {
  KolBl++;
  Ly=Hk1[1][1];                     //опред крайнего контура//
  Mx=Bk1[1][1];
  n=1;
  i=2;
  While(i<=k1)
  {
   if(floor(Bk1[i][1])<floor(Mx))
    {
     Mx=Bk1[i][1];
     Ly=Hk1[i][1];
     n=i;
    }
   if(floor(Bk1[i][1])==floor(Mx))
    if(Hk1[i][1]<Ly)
    { 
     Mx=Bk1[i][1];
     Ly=Hk1[i][1];
     n=i;                         //n-номер крайнего контура//
    }
   i++;
  }

 KolKt=1;
 end=0;
 While(end==0)
 {
  H1[1]=Hk1[n][1]-30;
  H2[1]=Hk2[n][1]+30;
  B1[1]=Bk1[n][1]-30;
  B2[1]=Bk2[n][1]+30;
  i=1;
  j=0;
  While(i<=k1)                                   //определение соседей//
  {
   if(MasKt[i][1]!=MasKt[n][1])
   {
    if( ((Hk1[i][1]<=H2[1])&&(Hk2[i][1]>=H1[1])) && ((Bk2[i][1]>=B1[1])&&(Bk1[i][1]<=B2[1])) ) 
    {
     j++;
     Kvr[j][1]=MasKt[i][1];
     Kvr[j][2]=i;
    }
   }
   i++;
  }
                                   //j-кол-во соседних контуров//   
  if(j==0)                          //если одиночный контур//
  {
   BLOK[1][KolBl]=1;
   BLOK[2][KolBl]=MasKt[n][1];
   end=1;
  } 


 if(j!=0)                                                     //опред след контура//
 {
 if(KolKt==1)
 {
  if(j==1)
  {
   KolKt++;
   BLOK[1][KolBl]=KolKt;
   BLOK[2][KolBl]=MasKt[n][1];
   BLOK[KolKt+1][KolBl]=Kvr[j][1];
   Pnx=Xck[Round(Kvr[j][2])][1]-Xck[n][1];
   Pny=Yck[Round(Kvr[j][2])][1]-Yck[n][1];   
   n=Round(Kvr[j][2]);
  }
  else
  {
   Pnx=Xck[Round(Kvr[j][2])][1]-Xck[n][1];
   Pny=Yck[Round(Kvr[j][2])][1]-Yck[n][1];
   CosF=(Px0*Pnx+Py0*Pny)/(sqrt(Px0*Px0+Py0*Py0)*sqrt(Pnx*Pnx+Pny*Pny));
   F=arccos(CosF);
   k=1;
   m=j;
   While(K<j)
   {
    Pnx=Xck[Round(Kvr[k][2])][1]-Xck[n][1];
    Pny=Yck[Round(Kvr[k][2])][1]-Yck[n][1];
    CosF=(Px0*Pnx+Py0*Pny)/(sqrt(Px0*Px0+Py0*Py0)*sqrt(Pnx*Pnx+Pny*Pny));
    F1=arccos(CosF);
    if(F1<F)
    {
     n1=F;
     F=F1;
     F1=n1;
     m=k;
    }
    k++;
   }
   KolKt++;
   BLOK[1][KolBl]=KolKt;
   BLOK[2][KolBl]=MasKt[n][1];
   BLOK[KolKt+1][KolBl]=Kvr[m][1];

   Pnx=Xck[Round(Kvr[m][2])][1]-Xck[n][1];
   Pny=Yck[Round(Kvr[m][2])][1]-Yck[n][1];
   n=Round(Kvr[m][2]);
  }
 }


 else
 {
  if(j==1)
  {
   Pn1x=Xck[Round(Kvr[j][2])][1]-Xck[n][1];
   Pn1y=Yck[Round(Kvr[j][2])][1]-Yck[n][1];

   CosF=(Pnx*Pn1x+Pny*Pn1y)/(sqrt(Pnx*Pnx+Pny*Pny)*sqrt(Pn1x*Pn1x+Pn1y*Pn1y));
   F=arccos(CosF);
   if(F<(3.1416/20))
   {
    KolKt++;
    BLOK[1][KolBl]=KolKt;
  //  BLOK[2][KolBl]=MasKt[n][1];
    BLOK[KolKt+1][KolBl]=Kvr[j][1];
    n=Round(Kvr[j][2]);
    Pnx=Pn1x;
    Pny=Pn1y;
   }
   else end=1;
  }
  else
  {
   Pn1x=Xck[Round(Kvr[j][2])][1]-Xck[n][1];
   Pn1y=Yck[Round(Kvr[j][2])][1]-Yck[n][1];
   CosF=(Px0*Pn1x+Py0*Pn1y)/(sqrt(Px0*Px0+Py0*Py0)*sqrt(Pn1x*Pn1x+Pn1y*Pn1y));
   F=arccos(CosF);
   k=1;
   m=j;
   While(K<j)
   {
    Pn1x=Xck[Round(Kvr[k][2])][1]-Xck[n][1];
    Pn1y=Yck[Round(Kvr[k][2])][1]-Yck[n][1];
    CosF=(Px0*Pn1x+Py0*Pn1y)/(sqrt(Px0*Px0+Py0*Py0)*sqrt(Pn1x*Pn1x+Pn1y*Pn1y));
    F1=arccos(CosF);
    if(F1<F)
    {
     n1=F;
     F=F1;
     F1=n1;
     m=k;
    }
    k++;
   }
   Pn1x=Xck[Round(Kvr[m][2])][1]-Xck[n][1];
   Pn1y=Yck[Round(Kvr[m][2])][1]-Yck[n][1];

   CosF=(Pnx*Pn1x+Pny*Pn1y)/(sqrt(Pnx*Pnx+Pny*Pny)*sqrt(Pn1x*Pn1x+Pn1y*Pn1y));
   F=arccos(CosF);
   if(F<(3.1416/20))
   {
    KolKt++;
    BLOK[1][KolBl]=KolKt;
   // BLOK[2][KolBl]=MasKt[n][1];
    BLOK[KolKt+1][KolBl]=Kvr[m][1];
    n=Round(Kvr[m][2]);
    Pnx=Pn1x;
    Pny=Pn1y;
   }
   else end=1;
  }
 }


}


 }


 i=1;
 k=0;
 While(i<=k1)                              //удаление контуров//
 {
  j=1;
  m=0;
  While(j<=BLOK[1][KolBl])
  {
   if(MasKt[i][1]==BLOK[j+1][KolBl]) m=1; 
   j++;
  }
  if(m==0)
  {
   k++;
   MasKt[k][1]=MasKt[i][1];
   Hk1[k][1]=Hk1[i][1];
   Hk2[k][1]=Hk2[i][1];
   Bk1[k][1]=Bk1[i][1];
   Bk2[k][1]=Bk2[i][1];
   Xck[k][1]=Xck[i][1];
   Yck[k][1]=Yck[i][1];  
  }

  i++;
 }

 k1=k;

 
 if(k1==0) stop=1;
 }

}


















j=1;
While(j<=KolBl)
{
 
  NEWFUN(320,0,BLOK[2][j]);
  Xc[1]=HEAP[56]+(HEAP[57]-HEAP[56])/2;
  Yc[1]=HEAP[58]+(HEAP[59]-HEAP[58])/2;
  B1[1]=HEAP[56];
  H1[1]=HEAP[58]; 
  NEWFUN(302,0,BLOK[2][j]);               // искать адрес текущего контура//
  NEWFUN(305,0,HEAP[25]);         // получить число спанов в контуре//
  i=1;
  While(i<HEAP[47])         //определим координаты вершин контура1//
  {
   NEWFUN(306,i,HEAP[25]);
   xk[i]=HEAP[35];
   yk[i]=HEAP[36];
   if(i==1)
    {
     D=sqrt((B1[1]-Xk[1])*(B1[1]-Xk[1])+(H1[1]-Yk[1])*(H1[1]-Yk[1]));
     Mx=i;
    }
   if(i!=1)
   {
    D1=sqrt((B1[1]-Xk[i])*(B1[1]-Xk[i])+(H1[1]-Yk[i])*(H1[1]-Yk[i])); 
    if(D1<D)
    {
     D=D1;
     Mx=i;
    }

   }
   i++;
  }  
  SPv=Mx;
  i=1;
  NMB=Round(BLOK[1][j])+1;
  While(i<=BLOK[1][j])
  {
   KNT[i]=BLOK[i+1][j];
   i++;
  }
 if(NMB==2)
 {
  TOF(123);
  MOVE(BLOK[i][j],Lange,SPv,0,spanvx);
  TON(123);
  PROF(BLOK[i][j],0,SPv,0,0,SPv,0,0);
 }
 else SN();
 j++;
}





















































