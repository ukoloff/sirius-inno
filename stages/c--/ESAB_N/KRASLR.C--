extern float W7,W8,W86,W87,W4,W101,W110,W120,DX[100],DY[100];
extern float DCutt,Lange;
extern float ShirPer;  // ширина перемычки
char   Left,OK,OK1,PER;
extern float W10,W11,W12;
float W1,W2;
extern float Ygol1[100],Ygol2[100];
extern long pin;
extern float Perx[100];
extern float Pery[100];
extern long W100;
extern long npodpr;
extern float pinok;
float A1,A2,AB,B1,B2;
float x3,y3,vixod,Tang;
float W71,W144,spann,posspn;
float xm,ym,xb,yb,xp1,yp1,xp10,yp10,xp2,yp2;
extern long Adres,Topik,ppod;
long pont,torez,verx,vniz,points;
long i1,i2,i3;

print("Укажите деталь длЯ резки с перемычкой,P-пп/ESC-выход)>");
W(-2);
if(OK==27)
{
 print("                                                            "); 
 return;
}          
x3=HEAP[22];     // ближайщаЯ точка к спану
y3=HEAP[21];     // ближайщаЯ точка к спану
W7=HEAP[3];      // номер контура
W4=HEAP[4];      // номер спана
W12=HEAP[8];     // ПозициЯ на спане 0..1
OK1:='Y';
OK :='Y';
if (S_GETCH==80)     // нажата клавиша P-подпрограмма
{
 ppod=1;
 Topik=80;
}
print("На торцах нужны перемычки? ([Y]/N/ESC)>");
W(-1);
if(S_GETCH>22) OK=S_GETCH;
if(OK==27)
{
 print("                                                            "); 
 return;
}     
if (OK=='Y') torez=1;
else torez=0;
OK='Y';
print("Сверху детали нужны перемычки? ([Y]/N/ESC)>");
W(-1);
if(S_GETCH>22) OK=S_GETCH;
if(OK==27)
{
 print("                                                            "); 
 return;
}     
if (OK=='Y') verx=1;
else verx=0;
OK='Y';
print("Снизу детали нужны перемычки? ([Y]/N/ESC)>");
W(-1);
if(S_GETCH>22) OK=S_GETCH;
if(OK==27)
{
 print("                                                            "); 
 return;
}     
if (OK=='Y') vniz=1;
else vniz=0;
pont=0;
points=0;
while(pont==0)
{
  print("Укажите место перемычки( " +str(points+1)+") /ESC-конец выбора )>");
  W(-2);
  if (S_GETCH==27) break; 
  points++;
  x3=HEAP[22];     // ближайщаЯ точка к спану
  y3=HEAP[21];     // ближайщаЯ точка к спану
  print("Введите координату Х("+str(x3)+")");
  read(x3);
  Perx[points-1]=x3;
  Pery[points-1]=y3;
}
if (points<1) return;
// *************** сортировка по х по убыванию**************************
if (points>1)
{
 i1=-1;
 i2=0;
 i3=points-1;
 while(i1<points)
 {
  i1++;
  while(i2<i3)
  {
   i2++;
   A1=Perx[i2-1];
   A2=Perx[i2];
   B1=Pery[i2-1];
   B2=Pery[i2];
   if (A1<A2)  // по убыванию
   {
    Perx[i2-1]=A2;
    Perx[i2]=A1;
    Pery[i2-1]=B2;
    Pery[i2]=B1;
   }
  }
  i2=0;
 }
}

if ((Topik==80) && (ppod==1)) /* нажата клавиша P */
{
 Topik=89;
}
// ***********************************************************
NEWFUN(302,0,W7);          // искать адрес текущего контура
//  При этом адрес контура  заноситсЯ в элемент массива HEAP[25];
W71=HEAP[25];              /* адрес текущего контура */
NEWFUN(303,0,W71);         /* искать номер главного (записи типа 8) */
if (NISTAT==1) 
{
 print("Ошибка! Нет детали -только контур, нажмите Л. К.");
 W(-1);
 return;
}
// При этом номер главного  заноситсЯ в элемент массива HEAP[26];
W144=HEAP[26];          // номер главного (записи типа 8)
NEWFUN(307,0,W144);     // получить адрес записи 8
// При этом адрес главного заноситсЯ в элемент массива   HEAP[27].
NewFun(308,HEAP[27],0);
W8=HEAP[43];             // адрес контура 1 в записи типа 8
W86=HEAP[44];           // адрес контура N в записи типа 8
NEWFUN(312,HEAP[27],W86);     // ГАБАРИТЫ ДЕТАЛИ
xm=HEAP[45];     // малый Х
xb=HEAP[46];     // большой Х
ym=HEAP[51];   // малый У
yb=HEAP[52];    // большой У
W86=HEAP[22];
W87=HEAP[21];
if (torez==1)
{
// xp1=xb+10;
 xp1=xb+ShirPer/2.0;
// yp1=(yb+ym)/2.0-10.0;
 yp1=(yb+ym)/2.0-ShirPer/2.0;
// xp10=xb+10.0;
 xp10=xb+ShirPer/2.0;
// yp10=(yb+ym)/2.0+10.0;
 yp10=(yb+ym)/2.0+ShirPer/2.0;
 NEWFUN(319,508,xp1);
 NEWFUN(319,509,yp1);
 NEWFUN(327,0,W7);
 spann=HEAP[115];
 posspn=HEAP[116];
 vixod=0.0;
 Tang=Lange;
 if (vniz==1) //  если есть снизу перемычки
 {
//  xp2=Perx[0]+20.0;
  xp2=Perx[0]+ShirPer;
  yp2=ym-100;
 }
 else
 {
  xp2=xm-100;
//  yp2=(yb+ym)/2.0-10.0;
  yp2=(yb+ym)/2.0-ShirPer/2.0;
 }
 RAPID();
 MOVE(W7,Lange,spann,posspn,0);
 // ********************************
 W86=XCURR;
 W87=YCURR;
 subrm();
 // ********************************
 KL();
 LEAD(0);
 PROF(W7,0,xp1,yp1,xp2,yp2);
 OFT();
}
else
{
// xp1=xb+10.0;
 xp1=xb+ShirPer/2.0;
 yp1=yb-1.0;
 xp10=xb-1.0;
// yp10=yb+10.0;
 yp10=yb+ShirPer/2.0;
 NEWFUN(319,508,xp1);
 NEWFUN(319,509,yp1);
 NEWFUN(327,0,W7); 
 spann=HEAP[115];
 posspn=0;
 vixod=-Lange;
 Tang=0.0;
 RAPID();
 MOVE(W7,0,spann,0,-Lange);
 // ********************************
 W86=XCURR;
 W87=YCURR;
 subrm();
 // ********************************
 KL();
 LEAD(0);
 if (vniz==1)
 {
//  xp2=Perx[0]+20.0;
  xp2=Perx[0]+ShirPer;
  yp2=ym-100;
  PROF(W7,0,xp1,yp1,xp2,yp2);
  OFT();
 }
 else
 {
  if (verx==1)
  {
   xp2=Perx[points-1];
   yp2=yb+100;
   PROF(W7,0,xp1,yp1,xp2,yp2);
   OFT();
  }
  else
  {
   xp2=xp10;
   yp2=yp10;
   PROF(W7,0,xp1,yp1,xp2,yp2);
   xp1=xp2;
   yp1=yp2;
   NEWFUN(319,508,xp1);
   NEWFUN(319,509,yp1);
   NEWFUN(327,0,W7); 
   spann=HEAP[115];
   OFT();
  }
 }  
}

// ************************ снизу  детали**************************
//   - начать вырезку перемычек на длинном спане снизу
// *****************************************************************
if ((vniz==1) && (points>1))
{
 i1=0;
 while(i1<points-1)
 {
  i1++;
  xp1=Perx[i1-1];
  yp1=ym-100.0;
  NEWFUN(319,508,xp1);
  NEWFUN(319,509,yp1);
  NEWFUN(327,0,W7);
  spann=HEAP[115];
  posspn=HEAP[116];
//  xp2=Perx[i1]+20.0;
  xp2=Perx[i1]+ShirPer;
  yp2=ym-100.0;
  RAPID();
  MOVE(W7,Lange,spann,posspn,0);
  KL();
  LEAD(0);
  PROF(W7,0,xp1,yp1,xp2,yp2);
  OFT();
 }
}
//  ***************************************************
//  Вырезка левого торца , если есть перемычка на торец
//  **************************************************
if (torez==1)
{
 if (vniz==1) //  если есть снизу перемычки
 {
  xp1=Perx[points-1];
  yp1=ym-100;
 }
 else
 {
  xp1=xm-100;
//  yp1=(yb+ym)/2.0+10.0;
  yp1=(yb+ym)/2.0+ShirPer/2.0;
 }
 NEWFUN(319,508,xp1);
 NEWFUN(319,509,yp1);
 NEWFUN(327,0,W7);
 spann=HEAP[115];
 posspn=HEAP[116];
 RAPID();
 MOVE(W7,Lange,spann,posspn,0);
 KL();
 LEAD(0);
 if (vniz==1)
 {
  xp2=xm-100;
//  yp2=(yb+ym)/2.0-10.0;
  yp2=(yb+ym)/2.0-ShirPer/2.0;
  PROF(W7,0,xp1,yp1,xp2,yp2);
  OFT();
  xp1=xm-100;
//  yp1=(yb+ym)/2.0+10.0;
  yp1=(yb+ym)/2.0+ShirPer/2.0;
  NEWFUN(319,508,xp1);
  NEWFUN(319,509,yp1);
  NEWFUN(327,0,W7);
  spann=HEAP[115];
  posspn=HEAP[116];
  RAPID();
  MOVE(W7,Lange,spann,posspn,0);
  KL();
  LEAD(0);
 }
 if (verx==1)
 {
  xp2=Perx[points-1];
  yp2=yb+100.0;
  PROF(W7,0,xp1,yp1,xp2,yp2);
  OFT();
 }
 else
 {
  xp2=xp10;
  yp2=yp10;
  PROF(W7,0,xp1,yp1,xp2,yp2);
  xp1=xp2;
  yp1=yp2;
  NEWFUN(319,508,xp1);
  NEWFUN(319,509,yp1);
  NEWFUN(327,0,W7); 
  spann=HEAP[115];
  OFT();
 }
}
else   //  нет торца
{
 if (vniz==1)
 {
  xp1=Perx[points-1];
  yp1=ym-100;
  NEWFUN(319,508,xp1);
  NEWFUN(319,509,yp1);
  NEWFUN(327,0,W7);
  spann=HEAP[115];
  posspn=HEAP[116];
  RAPID();
  MOVE(W7,Lange,spann,posspn,0);
  KL();
  LEAD(0);
  if (verx==1)
  {
   xp2=Perx[points-1];
   yp2=yb+100.0;
   PROF(W7,0,xp1,yp1,xp2,yp2);
   OFT();
  }
  else
  {
   xp2=xp10;
   yp2=yp10;
   PROF(W7,0,xp1,yp1,xp2,yp2);
   xp1=xp2;
   yp1=yp2;
   NEWFUN(319,508,xp1);
   NEWFUN(319,509,yp1);
   NEWFUN(327,0,W7); 
   spann=HEAP[115];
   OFT();
  }       
 }
}
// ********************************************************
// **************ВерхнЯЯ  длиннаЯ сторона***
//  ******************************************************
// print("Выход правильный=verx=("+str(verx)+")");
// read(verx);

if ((verx==1) && (points>1))
{
 i1=points;
 while(i1>1)
 {
  i1--;
//  xp1=Perx[i1]+20.0;
  xp1=Perx[i1]+ShirPer;
  yp1=yb+100.0;
  NEWFUN(319,508,xp1);
  NEWFUN(319,509,yp1);
  NEWFUN(327,0,W7);
  spann=HEAP[115];
  posspn=HEAP[116];
  xp2=Perx[i1-1];
  yp2=yb+100.0;
  RAPID();
  MOVE(W7,Lange,spann,posspn,0);
  KL();
  LEAD(0);
  PROF(W7,0,xp1,yp1,xp2,yp2);
  OFT();
 }
}
// ************************************************
// завершающаЯ стадиЯ --- перемычки на торцах или нет
//  ***********************************************
// print("Выход =points=("+str(points)+")");
// read(points);
if (verx==1)
{
// xp1=Perx[0]+20.0;
 xp1=Perx[0]+ShirPer;
 yp1=yb+100.0;
 NEWFUN(319,508,xp1);
 NEWFUN(319,509,yp1);
 NEWFUN(327,0,W7);
 spann=HEAP[115];
 posspn=HEAP[116];
 RAPID();
 MOVE(W7,Lange,spann,posspn,0);
 KL();
 LEAD(0);
 if (torez==1)
 {
  xp2=xb+100.0;
//  yp2=(yb+ym)/2.0+10.0;
  yp2=(yb+ym)/2.0+ShirPer/2.0;
  PROF(W7,0,xp1,yp1,xp2,yp2); 
  OFT();
 }
 else
 {
  xp2=xp10;
  yp2=yp10;
  PROF(W7,0,xp1,yp1,xp2,yp2); 
  xp1=xp2;
  yp1=yp2;
  NEWFUN(319,508,xp1);
  NEWFUN(319,509,yp1);
  NEWFUN(327,0,W7);
  spann=HEAP[115];
  posspn=HEAP[116];
  OFT();
 }
}
ppkon(); 
BLOK();