float KTn[300],KTv[300],Xc[300],Yc[300],H1[300],B1[300],H2[300],B2[300],NM,NM1,Mx,Dx,Ly,Vrem[300],Vrem1[300],Xck[4][300],Yck[4][300],MinX,MinY;
Long NambV,del,stop,end,H,pr;
char putin[100],stroka[150];
Long filt,i,j,k1,k2,k3,n,n2,k,m,m1,kolKt,KBl,m2,rot;
float Px0,Py0,Px1,Py1,KVr[5][300],Pnx,Pny,Pn1x,Pn1y,CosF,F,F1,n1,Xk[300],yk[300],D,D1,Hg,Bg,Hg1,Bg1,NBl,CosFx,Fx,F2,PBL,W1,W2;
Extern float BLOK[300][300],KNT[100],SPv,ODKont[300][300],MasKt[4][300],ParBl[10][300],Hk1[4][300],Hk2[4][300],Bk1[4][300],Bk2[4][300];
Extern Long KolBl,KolBl1,NMB,KBl1,NambN;
extern float Lange;    // дистанциЯ врезки
extern float spanvx;   //    выход из способа резки УГОЛ

putin=PATHNAM+"REZVREM.RRR";
NEWFUN(323,0,0);                 //Сортировка контуров//
NEWFUN(322,0,0);



Filt:=fopen(putin,"rt");         //Выбор внешних контуров//
NambN=1;
fscan(Filt,stroka);
//Napr:=Val(substr(stroka,61,6));        //Направление реза//
NM=Val(substr(stroka,53,6));
KTn[NambN]=Val(substr(stroka,1,7));
while(! feof(Filt))
{  
 fscan(Filt,stroka);
 NM1=Val(substr(stroka,53,6));
 if(NM!=NM1) 
  {
   NambN++;
   KTn[NambN]=Val(substr(stroka,1,7));
   NM=NM1;

  }
  else KTn[NambN]=Val(substr(stroka,1,7));

}
fseek(Filt,0);                                    //Внутренние контура//
i=1;
NambV=0;
while(! feof(Filt))
{
 fscan(Filt,stroka);

 if(KTn[i]==Val(substr(stroka,1,7))) i++;
  else
   {
    NambV++;
    KTv[NambV]=Val(substr(stroka,1,7));
   }
}
if(KTv[NambV]==KTn[NambN-1]) NambV--;
NambN--;

i=1;
k1=0;
While(i<=NambN)                    //координаты центра опис пр,шир и выс//
{
 //if(KTn[i]!=1)
  {
 k1++;
 NEWFUN(320,0,KTn[k1]);
 Xc[k1]=HEAP[56]+(HEAP[57]-HEAP[56])/2;
 Yc[k1]=HEAP[58]+(HEAP[59]-HEAP[58])/2;
 //B[i]= HEAP[57]-HEAP[56];                
 //H[i]= HEAP[59]-HEAP[58];
 B1[k1]=HEAP[56];
 B2[k1]=HEAP[57];
 H1[k1]=HEAP[58];
 H2[k1]=HEAP[59];
   
   MasKt[k1][1]=KTn[i];
   Hk1[k1][1]=H1[i];
   Hk2[k1][1]=H2[i];
   Bk1[k1][1]=B1[i];
   Bk2[k1][1]=B2[i];
   Xck[k1][1]=Xc[i];
   Yck[k1][1]=Yc[i];
   Vrem[k1]=MasKt[k1][1];
   Vrem1[k1]=k1;
  }  
 i++;
}



j=1;
KBl=0;
KolKt=1;
While(j<=k1)                         //опред блоков один контуров
{
 if(Vrem[j]!=-100)
 {
  KBl++;
  KolKt=1;
  ODKont[1][KBl]=KolKt;
  ODKont[2][KBl]=Vrem[j];
  MasKt[j][2]=KBl;
  Hg=H2[j]-H1[j];
  Bg=B2[j]-B1[j];
  Vrem[j]=-100;
  i=1;
  While(i<=K1)
  {
   if(Vrem[i]!=-100)
   {
    if( (Round(Hg)==Round(H2[i]-H1[i])) && (Round(Bg)==Round(B2[i]-B1[i])) )
     {
      KolKt++;
      ODKont[1][KBl]=KolKt;
      ODKont[KolKt+1][KBl]=Vrem[i];
      MasKt[i][2]=KBl;
      Vrem[i]=-100;
     }
   }

   i++;
  }
 }
j++;
}




KolBl1=150;
i=1;



While(i<=KBl)
{
 KBl1=i;
 SNBLOK();
 i++;
}

i=1;
While(i<=NambN)
{
 Xck[i][1]=Bk1[i][1]+(Bk2[i][1]-Bk1[i][1])/2;
 Yck[i][1]=Hk1[i][1]+(Hk2[i][1]-Hk1[i][1])/2;
 i++;
}
















j=151;
if(j==200)
{


 While(j<=KolBl)
 {
  i=1;
  TOF(123);
  MOVE(BLOK[i+1][j],0,1,0,0);
  TON(123);
  While(i<=BLOK[1][j])
  {
   PROF(BLOK[i+1][j],0,1,0,0,1,0,0);
   i++;
  }
  j++;
 }


}










del=1;
if(del==1)
{



Px0=0;
PY0=1;
Px1=1;
Py1=0;
KolBl=0;
stop=0;
end=0;
KolKt=1;
k1=NambN;


pr=1;

While(stop==0)
 {
  PBl=0;
  KolBl++;
  end=0;
  Ly=Hk1[1][1];                     //опред крайнего контура//
  Mx=Bk1[1][1];  
  n=1;
  i=2;
  While(i<=k1)
  {
   if(floor(Bk1[i][1])<floor(Mx))
    {
     Mx=Bk1[i][1];
     Ly=Hk1[i][1];
     n=i;
    }
   if(floor(Bk1[i][1])==floor(Mx))
    if(Hk1[i][1]<Ly)
    { 
     Mx=Bk1[i][1];
     Ly=Hk1[i][1];
     n=i;                         //n-номер крайнего контура//
    }
   i++;
  }




 if(MasKt[n][1]==-100)
 {
  PBL=n;
  end=1;
  i=Round(MasKt[n][2]);
  j=1;
  While(j<=BLOK[1][i])
  {
   BLOK[1][KolBl]=BLOK[1][i];
   BLOK[j+1][KolBl]=BLOK[j+1][i];
   j++;
  }

 }



 KolKt=1;
 While(end==0)
 {
  H1[1]=Hk1[n][1]-30;
  H2[1]=Hk2[n][1]+30;
  B1[1]=Bk1[n][1]-30;
  B2[1]=Bk2[n][1]+30;
  i=1;
  j=0;
  While(i<=k1)                                   //определение соседей//
  {
   if(MasKt[i][1]!=MasKt[n][1])
   {
    if( ((Hk1[i][1]<=H2[1])&&(Hk2[i][1]>=H1[1])) && ((Bk2[i][1]>=B1[1])&&(Bk1[i][1]<=B2[1])) ) 
    {
     j++;
     Kvr[j][1]=MasKt[i][1];                     //j-кол-во соседних контуров// 
     Kvr[j][2]=i;
    }
   }
   i++;
  }
                                         
   

  if(j==0)                             //если одиночный контур//
  {
   BLOK[1][KolBl]=1;
   BLOK[2][KolBl]=MasKt[n][1];
   end=1;
  } 


 if(j!=0)                                                     //опред след контура//
 {
 if(KolKt==1)
 {
  if(j==1)
  {
   if(Kvr[j][1]==-100)
   {
    end=1;
    BLOK[1][KolBl]=1;
    BLOK[2][KolBl]=MasKt[n][1];
 
   }
   else
   {
   KolKt++;
   BLOK[1][KolBl]=KolKt;
   BLOK[2][KolBl]=MasKt[n][1];
   BLOK[KolKt+1][KolBl]=Kvr[j][1];
   Pnx=Xck[Round(Kvr[j][2])][1]-Xck[n][1];
   Pny=Yck[Round(Kvr[j][2])][1]-Yck[n][1];   
   n=Round(Kvr[j][2]);
   }
  }
  else
  {
   k=1;
   m=0;
   While(k<=j)
   {
    if(Kvr[k][1]!=-100) m=k;    
    k++;
   }
   if(m==0)
   {
    end=1;
    BLOK[1][KolBl]=1;
    BLOK[2][KolBl]=MasKt[n][1];
   }

   if(m!=0)
   {
    Pnx=Xck[Round(Kvr[m][2])][1]-Xck[n][1];
    Pny=Yck[Round(Kvr[m][2])][1]-Yck[n][1];
    CosF=(Px0*Pnx+Py0*Pny)/(sqrt(Px0*Px0+Py0*Py0)*sqrt(Pnx*Pnx+Pny*Pny));
    CosFx=(Px1*Pnx+Py1*Pny)/(sqrt(Px1*Px1+Py1*Py1)*sqrt(Pnx*Pnx+Pny*Pny));
    F=arccos(CosF);
    Fx=arccos(CosFx);
    m1=m; 
    k=1; 
    //print(F);
    //print(Fx);
  // print(Xck[Round(Kvr[m][2])][1]);
  // print(Yck[Round(Kvr[m][2])][1]);
   While(K<j)
   {
    if(Kvr[k][1]!=-100)
    {
     Pnx=Xck[Round(Kvr[k][2])][1]-Xck[n][1];
     Pny=Yck[Round(Kvr[k][2])][1]-Yck[n][1];
     CosF=(Px0*Pnx+Py0*Pny)/(sqrt(Px0*Px0+Py0*Py0)*sqrt(Pnx*Pnx+Pny*Pny));
     CosFx=(Px1*Pnx+Py1*Pny)/(sqrt(Px1*Px1+Py1*Py1)*sqrt(Pnx*Pnx+Pny*Pny));
     F1=arccos(CosF);
     F2=arccos(CosFx);
     if(F1<F)
     {
      n1=F;
      F=F1;
      F1=n1;
      m=k;
     }
     if(F2<Fx)
     {
      n1=Fx;
      Fx=F2;
      F2=n1;
      m1=k;
     }
    }
    k++;
   }
  // print(F);
  // print(Fx);
   if(Fx<F) m=m1;
   KolKt++;
   BLOK[1][KolBl]=KolKt;
   BLOK[2][KolBl]=MasKt[n][1];
   BLOK[KolKt+1][KolBl]=Kvr[m][1];

   Pnx=Xck[Round(Kvr[m][2])][1]-Xck[n][1];
   Pny=Yck[Round(Kvr[m][2])][1]-Yck[n][1];
   n=Round(Kvr[m][2]);
  }
 }
  
 }


 else
 {
  if(j==1)
  {
   if(Kvr[j][1]==-100) end=1;
   else
   {

   Pn1x=Xck[Round(Kvr[j][2])][1]-Xck[n][1];
   Pn1y=Yck[Round(Kvr[j][2])][1]-Yck[n][1];

   CosF=(Pnx*Pn1x+Pny*Pn1y)/(sqrt(Pnx*Pnx+Pny*Pny)*sqrt(Pn1x*Pn1x+Pn1y*Pn1y));
   F=arccos(CosF);
   if(F<(3.1416/20))
   {
    KolKt++;
    BLOK[1][KolBl]=KolKt;
  //  BLOK[2][KolBl]=MasKt[n][1];
    BLOK[KolKt+1][KolBl]=Kvr[j][1];
    n=Round(Kvr[j][2]);
    Pnx=Pn1x;
    Pny=Pn1y;
   }
   else end=1;
   }
  }
  else
  {
   k=1;
   m=0;
   While(k<=j)
   {
    if(Kvr[k][1]!=-100) m=k;   
    k++;
   }
   if(m==0) end=1;
   
   if(m!=0)
   {
    Pn1x=Xck[Round(Kvr[m][2])][1]-Xck[n][1];
    Pn1y=Yck[Round(Kvr[m][2])][1]-Yck[n][1];
    CosF=(Px0*Pn1x+Py0*Pn1y)/(sqrt(Px0*Px0+Py0*Py0)*sqrt(Pn1x*Pn1x+Pn1y*Pn1y));
    CosFx=(Px1*Pn1x+Py1*Pn1y)/(sqrt(Px1*Px1+Py1*Py1)*sqrt(Pn1x*Pn1x+Pn1y*Pn1y));
    F=arccos(CosF); 
    Fx=arccos(CosFx);
    m1=m;
   k=1;
   While(K<j)
   {
    if(Kvr[k][1]!=-100)
    {
     Pn1x=Xck[Round(Kvr[k][2])][1]-Xck[n][1];
     Pn1y=Yck[Round(Kvr[k][2])][1]-Yck[n][1];
     CosF=(Px0*Pn1x+Py0*Pn1y)/(sqrt(Px0*Px0+Py0*Py0)*sqrt(Pn1x*Pn1x+Pn1y*Pn1y));
     CosFx=(Px1*Pn1x+Py1*Pn1y)/(sqrt(Px1*Px1+Py1*Py1)*sqrt(Pn1x*Pn1x+Pn1y*Pn1y));
     F1=arccos(CosF);
     F2=arccos(CosFx);
     if(F1<F)
     {
      n1=F;
      F=F1;
      F1=n1;
      m=k;
     }
     if(F2<Fx)
     {
      n1=Fx;
      Fx=F2;
      F2=n1;
      m1=k;
     }
    }
    k++;
   }
   if(Fx<F) m=m1;
   Pn1x=Xck[Round(Kvr[m][2])][1]-Xck[n][1];
   Pn1y=Yck[Round(Kvr[m][2])][1]-Yck[n][1];

   CosF=(Pnx*Pn1x+Pny*Pn1y)/(sqrt(Pnx*Pnx+Pny*Pny)*sqrt(Pn1x*Pn1x+Pn1y*Pn1y));
   F=arccos(CosF);
   if(F<(3.1416/20))
   {
    KolKt++;
    BLOK[1][KolBl]=KolKt;
   // BLOK[2][KolBl]=MasKt[n][1];
    BLOK[KolKt+1][KolBl]=Kvr[m][1];
    n=Round(Kvr[m][2]);
    Pnx=Pn1x;
    Pny=Pn1y;
   }
   else end=1;
  }
 }
}


}


 }


 i=1;
 k=0;
 if(PBL!=0)
 {
  While(i<k1) 
  {
   if(i>=PBL)
   {
    MasKt[i][1]=MasKt[i+1][1];
    MasKt[i][2]=MasKt[i+1][2];
    Hk1[i][1]=Hk1[i+1][1];
    Hk2[i][1]=Hk2[i+1][1];
    Bk1[i][1]=Bk1[i+1][1];
    Bk2[i][1]=Bk2[i+1][1];
    Xck[i][1]=Xck[i+1][1];
    Yck[i][1]=Yck[i+1][1]; 
   }

   i++;
  }

 k1--;
 }
 else
 {
 i=1;
 k=0;
 While(i<=k1)                              //удаление контуров//
 {
  j=1;
  m=0;
  While(j<=BLOK[1][KolBl])
  {
   if(MasKt[i][1]==BLOK[j+1][KolBl]) m=1; 
   j++;
  }
  if(m==0)
  {
   k++;
   MasKt[k][1]=MasKt[i][1];
   MasKt[k][2]=MasKt[i][2];
   Hk1[k][1]=Hk1[i][1];
   Hk2[k][1]=Hk2[i][1];
   Bk1[k][1]=Bk1[i][1];
   Bk2[k][1]=Bk2[i][1];
   Xck[k][1]=Xck[i][1];
   Yck[k][1]=Yck[i][1];  
  }

  i++;
 }

 k1=k;
 }
 
 if(k1==0) stop=1;

 //if(pr==5) stop=1;
 pr++;
 }




}










j=1;
if(j==1)
{


//SPv=1;


j=1;

 
While(j<=KolBl)                               //опред точки врезки//
{
 rot=0;
 W1=BLOK[2][j];
 W2=BLOK[Round(BLOK[1][j]+1)][j];
 
 NEWFUN(320,0,W1);
 Xck[1][1]=HEAP[56]+(HEAP[57]-HEAP[56])/2;
 Yck[1][1]=HEAP[58]+(HEAP[59]-HEAP[58])/2;
 Bk1[1][1]=HEAP[56];
 Bk2[1][1]=HEAP[57];
 Hk1[1][1]=HEAP[58];
 Hk2[1][1]=HEAP[59];

 NEWFUN(320,0,W2);
 Xck[1][2]=HEAP[56]+(HEAP[57]-HEAP[56])/2;
 Yck[1][2]=HEAP[58]+(HEAP[59]-HEAP[58])/2;
 Bk1[1][2]=HEAP[56];
 Bk2[1][2]=HEAP[57];
 Hk1[1][2]=HEAP[58];
 Hk2[1][2]=HEAP[59];

 if(W1!=W2)
 {
  Pnx=Xck[1][2]-Xck[1][1];
  Pny=Yck[1][2]-Yck[1][1];
  CosF=(Px0*Pnx+Py0*Pny)/(sqrt(Px0*Px0+Py0*Py0)*sqrt(Pnx*Pnx+Pny*Pny));
  F=arccos(CosF)*180/3.1416;
  n1=Px0*Pny-Py0*Pnx;                        //направление вектора//
  if(Round(n1)>=0) F=0;
  
  if(F<=20)
  {
   NEWFUN(302,0,w1);               // искать адрес текущего контура//
   NEWFUN(305,0,HEAP[25]);         // получить число спанов в контуре//  
 
   i=1;
   While(i<HEAP[47])              //определим координаты вершин контура//
   {
    NEWFUN(306,i,HEAP[25]);
    xc[i]=HEAP[35];
    yc[i]=HEAP[36];                //точка врезки-прав верх верш
    if(i==1)
    {
     D=sqrt((Bk2[1][1]-Xc[1])*(Bk2[1][1]-Xc[1])+(Hk1[1][1]-Yc[1])*(Hk1[1][1]-Yc[1]));
     Mx=i;
    }
    if(i!=1)
    {
     D1=sqrt((Bk2[1][1]-Xc[i])*(Bk2[1][1]-Xc[i])+(Hk1[1][1]-Yc[i])*(Hk1[1][1]-Yc[i]));
     if(D1<D)
     {
      D=D1;
      Mx=i;
     }
    }
    i++;
   }
   SPv=Mx;
  }
  if(F>20)
  {
   rot=1;
   W1=W2;
   Xck[1][1]=Xck[1][2];
   Yck[1][1]=Yck[1][2];
   Bk1[1][1]=Bk1[1][2];
   Bk2[1][1]=Bk2[1][2];
   Hk1[1][1]=Hk1[1][2];
   Hk2[1][1]=Hk2[1][2];              
   
   NEWFUN(302,0,w1);               // искать адрес текущего контура//
   NEWFUN(305,0,HEAP[25]);         // получить число спанов в контуре//  
 
   i=1;
   While(i<HEAP[47])              //определим координаты вершин контура//
   {
    NEWFUN(306,i,HEAP[25]);
    xc[i]=HEAP[35];
    yc[i]=HEAP[36];                //точка врезки-прав верх верш
    if(i==1)
    {
     D=sqrt((Bk2[1][1]-Xc[1])*(Bk2[1][1]-Xc[1])+(Hk2[1][1]-Yc[1])*(Hk2[1][1]-Yc[1]));
     Mx=i;
    }
    if(i!=1)
    {
     D1=sqrt((Bk2[1][1]-Xc[i])*(Bk2[1][1]-Xc[i])+(Hk2[1][1]-Yc[i])*(Hk2[1][1]-Yc[i]));
     if(D1<D)
     {
      D=D1;
      Mx=i;
     }
    }
    i++;
   }
   SPv=Mx;
  }
 }
 else
 {
  NEWFUN(302,0,w1);               // искать адрес текущего контура//
  NEWFUN(305,0,HEAP[25]);         // получить число спанов в контуре//  
 
   i=1;
   While(i<HEAP[47])              //определим координаты вершин контура//
   {
    NEWFUN(306,i,HEAP[25]);
    xc[i]=HEAP[35];
    yc[i]=HEAP[36];                //точка врезки-прав верх верш
    if(i==1)
    {
     D=sqrt((Bk2[1][1]-Xc[1])*(Bk2[1][1]-Xc[1])+(Hk1[1][1]-Yc[1])*(Hk1[1][1]-Yc[1]));
     Mx=i;
    }
    if(i!=1)
    {
     D1=sqrt((Bk2[1][1]-Xc[i])*(Bk2[1][1]-Xc[i])+(Hk1[1][1]-Yc[i])*(Hk1[1][1]-Yc[i]));
     if(D1<D)
     {
      D=D1;
      Mx=i;
     }
    }
    i++;
   }
   SPv=Mx;
 }





NMB=Round(BLOK[1][j])+1;

 if(rot==1)
 {
  i=Round(BLOK[1][j]);
  k=1;
  While(i>=1)
  {
   KNT[k]=BLOK[i+1][j];
   i--;
   k++;
  }
 }
 else
 {
  i=1;
  While(i<=BLOK[1][j])
  {
   KNT[i]=BLOK[i+1][j];
   i++;
  }
 }

 if(NMB==2)
 {
  TOF(123);
  MOVE(BLOK[i][j],Lange,SPv,0,spanvx);
  TON(123);
  PROF(BLOK[i][j],0,SPv,0,0,SPv,0,0);
 }
 else SN();
 

 j++;
}

 TOF(123);


}


 //print(BLOK[1][2]);
 //print(BLOK[2][2]);

 




 //print(KNT[1]);
 //print(KNT[2]);
 //print(KNT[3]);
 //print(KNT[4]);




del=1;
if(del==10)
{





j=1;
//TON(123);
While(j<=KolBl)
{
 NEWFUN(320,0,BLOK[2][j]);
 Xc[1]=HEAP[56]+(HEAP[57]-HEAP[56])/2;
 Yc[1]=HEAP[58]+(HEAP[59]-HEAP[58])/2;
 B1[1]=HEAP[56];
 H1[1]=HEAP[58];

 NEWFUN(302,0,BLOK[2][j]);               // искать адрес текущего контура//
 NEWFUN(305,0,HEAP[25]);         // получить число спанов в контуре//

   
 i=1;
 While(i<HEAP[47])         //определим координаты вершин контура1//
 {
  NEWFUN(306,i,HEAP[25]);
  xk[i]=HEAP[35];
  yk[i]=HEAP[36];
  if(i==1)
  {
   D=sqrt((B1[1]-Xk[1])*(B1[1]-Xk[1])+(H1[1]-Yk[1])*(H1[1]-Yk[1]));
   Mx=i;
  }
  if(i!=1)
  {
   D1=sqrt((B1[1]-Xk[i])*(B1[1]-Xk[i])+(H1[1]-Yk[i])*(H1[1]-Yk[i])); 
   if(D1<D)
   {
    D=D1;
    Mx=i;
   }

  }

  i++;
 }


SPv=Mx;


}




SPv=1;
print("AAA"); 
i=1;
//if(i==10)
//{
NMB=Round(BLOK[1][j])+1;

While(i<=BLOK[1][j])

{
 KNT[i]=BLOK[i+1][j];
 i++;
}
 //UPCUT();
 if(NMB==2)
 {
  TOF(123);
  MOVE(BLOK[i][j],Lange,SPv,0,spanvx);
  TON(123);
  PROF(BLOK[i][j],0,SPv,0,0,SPv,0,0);
 }
 else SN();
 

 j++;
}












































