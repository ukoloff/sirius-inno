extern float Xk1[200],yk1[200],KNT[100],Xk2[200],yk2[200],Tk1[200],Tk2[200],Kolspan1,Kolspan2,DPER;
extern long NMB,NMB1,nomR1[100],nomR2[100];
float NomSpVr,PozSpVr,P77,P7,D,min1,min;
long KolSp,KolSp1,KolSp2,nom1,nom2;

NEWFUN(302,0,KNT[NMB]);               // искать адрес текущего контура//
P77=HEAP[25];
NEWFUN(305,0,P77);         // получить число спанов в контуре
KolSpan2=HEAP[47];
if (KolSpan2<2) return;
KolSp=1;
While(KolSP<=KolSpan2)      //определЯем координаты вершин контура2//
{
 NEWFUN(306,KolSP,P77);
 xk2[KolSp]=HEAP[35];
 yk2[KolSp]=HEAP[36];
 Tk2[KolSp]=HEAP[37];
 KolSp++;
}
KolSp1=1;
KolSp2=1;
D=sqrt((xk2[KolSp2]-xk1[KolSp1])*(xk2[KolSp2]-xk1[KolSp1])+(yk2[KolSp2]-yk1[KolSp1])*(yk2[KolSp2]-yk1[KolSp1]));
min1=D;
nom1=KolSp1;
nom2=KolSp2;
KolSP2=2;
While(KolSp2<KolSpan2)
{
 D=sqrt((xk2[KolSp2]-xk1[KolSp1])*(xk2[KolSp2]-xk1[KolSp1])+(yk2[KolSp2]-yk1[KolSp1])*(yk2[KolSp2]-yk1[KolSp1]));
 if(D<min1)
  {
   min1=D;
   nom1=KolSp1;
   nom2=KolSp2;
  }
 KolSp2++;
}

KolSp1=2;
min=min1;
nomR1[NMB1]=nom1;
nomR2[NMB1]=nom2;
While(KolSp1<KolSpan1)
{
 KolSp2:=1;
 D=sqrt((xk2[KolSp2]-xk1[KolSp1])*(xk2[KolSp2]-xk1[KolSp1])+(yk2[KolSp2]-yk1[KolSp1])*(yk2[KolSp2]-yk1[KolSp1]));
 min1=D;
 nom1=KolSp1;
 nom2=KolSp2;
 KolSP2=2;
 While(KolSp2<KolSpan2)
 {
  D=sqrt((xk2[KolSp2]-xk1[KolSp1])*(xk2[KolSp2]-xk1[KolSp1])+(yk2[KolSp2]-yk1[KolSp1])*(yk2[KolSp2]-yk1[KolSp1]));
  if(D<min1)
   {
    min1=D;
    nom1=KolSp1;
    nom2=KolSp2;
   }
  KolSp2++;
 }
 if(min1<min)
 {
  min=min1;
  nomR1[NMB1]=nom1;
  nomR2[NMB1]=nom2;
 }
 KolSp1++;
}


DPER=sqrt((xk2[nomR2[NMB1]]-xk1[nomR1[NMB1]])*(xk2[nomR2[NMB1]]-xk1[nomR1[NMB1]])+(yk2[nomR2[NMB1]]-yk1[nomR1[NMB1]])*(yk2[nomR2[NMB1]]-yk1[nomR1[NMB1]]));
